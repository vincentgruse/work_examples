/*
 * Vincent Gruse
 * Programming Assignment 3
 * Problem 1 (Binary Heaps)
 * Takes in 5000 positive integers generated by a random function ranged between 0 and 50000
 * and outputs the total number of swappings, the first 50 elements in the result of the insert
 * and the linear-time heaps, and prints the execution times for both.
 */

import java.util.Random;

class Heap {
    private int[] heapArray; // The array holding the heap elements
    private int capacity; // Maximum capacity of the heap
    private int currentSize; // Current number of elements in the heap
    private int swaps; // Counter to track the number of swaps during operations

    // Constructor
    public Heap(int n) {
        capacity = n;
        heapArray = new int[capacity];
        currentSize = 0;
        swaps = 0;
    }

    // Set the heap array and update the current size
    public void setHeapArray(int[] arr) {
        this.heapArray = arr.clone();
        this.currentSize = arr.length;
    }

    // Calculate the index of the parent node of a given key
    private int parent(int key) {
        return (key - 1) / 2;
    }

    // Swap two elements in the array and increment the swap counter
    private void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
        swaps++;
    }

    // Insert a new element into the heap and maintain the heap property
    public void insertKey(int k) {
        int n = currentSize;
        heapArray[n] = k; // Add the new element at the end
        currentSize++;

        // Heapify upwards to fix the heap property
        while (n != 0 && heapArray[n] < heapArray[parent(n)]) {
            swap(heapArray, n, parent(n));
            n = parent(n);
        }
    }

    // Perform the heapify operation on a specific node in the heap
    public void heapify(int[] arr, int n, int i) {
        int parent = i; // Initialize the parent as the root node
        int left = 2 * i + 1; // Left child
        int right = 2 * i + 2; // Right child

        // Find the parent element and its children
        if (left < n && arr[left] < arr[parent]) {
            parent = left;
        }

        if (right < n && arr[right] < arr[parent]) {
            parent = right;
        }

        // If the parent element is not the node itself, swap and heapify further
        if (parent != i) {
            swap(heapArray, i, parent);
            heapify(arr, n, parent);
        }
    }

    // Build a heap from the heapArray
    public void buildHeap() {
        int n = currentSize;
        int start = (n / 2) - 1;

        // Start heapifying from the last non-leaf node to the root
        for (int i = start; i >= 0; i--) {
            heapify(heapArray, n, i);
        }
    }

    // Get the number of swaps performed during operations
    public int getSwaps() {
        return swaps;
    }

    // Print the first 50 elements of the heapArray
    public void printHeap() {
        System.out.print("First 50 elements:\n{");
        for (int i = 0; i < 50; i++) {
            System.out.print(heapArray[i] + ", ");
        }
        System.out.println("... , " + heapArray[heapArray.length - 1] + "}");
    }
}

class BinaryHeap {
    private static Random rand = new Random();

    // Generate an array of random numbers
    private static int[] generateRandomNumbers(int count) {
        int[] randomNumbers = new int[count];
        for (int i = 0; i < count; i++) {
            randomNumbers[i] = rand.nextInt(50001); // Range: 0 to 50000
        }
        return randomNumbers;
    }

    public static void main(String[] args) {
        int[] randomNumbers = generateRandomNumbers(5000);

        // Program 1: Insert elements one-by-one into a heap and measure runtime
        System.out.println("*** Program 1 ***");
        Heap h = new Heap(randomNumbers.length);
        long startTime = System.nanoTime();

        for (int num : randomNumbers) {
            h.insertKey(num);
        }

        long endTime = System.nanoTime();
        double runtime = (endTime - startTime) / 1000000.0;

        h.printHeap();
        System.out.println("\nSwaps: " + h.getSwaps());
        System.out.println("Runtime: " + runtime + " milliseconds");

        // Program 2: Build a heap in linear-time from an array and measure runtime
        System.out.println("\n*** Program 2 ***");
        Heap hLinear = new Heap(randomNumbers.length);
        hLinear.setHeapArray(randomNumbers);

        startTime = System.nanoTime();

        hLinear.buildHeap();

        endTime = System.nanoTime();
        runtime = (endTime - startTime) / 1000000.0;

        hLinear.printHeap();
        System.out.println("\nSwaps: " + hLinear.getSwaps());
        System.out.println("Runtime: " + runtime + " milliseconds");
    }
}
